Intellisense starts working when .csproj are added to Solution
Dotnet commands:
- listing available templates: dotnet new list
- Creating Solution: dotnet new sln
- Creating a webAPi project: dotnet new webapi --name API -controllers
- Creating a class library: dotnet new classlib [-n|--name]
- Adding created projects/templates to solution: dotnet sln add <Project>

Project Structure:
- Domain is in the core and has no dependencies. Contains core business logic
- Appplication depends on Domain and Persistence. 
- API depends on Application
- Persistence depends on Domain


Running the project:
- Server: Go to API folder and run dotnet watch
- Client: npm run dev (client uses vite.)



SECTION 1:

- Project we created is a Web-Api project. It doesn't have any views to display in browser. The responsiblity of
API project is to intercept HTTP requests and send responses. It does that via API end-points
- [Route("[controller]")]: https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-9.0
The tokens [action], [area], and [controller] are replaced with the values of the action name, area name, and controller name from the action where the route is defined

Migrations:
EntityFramework(EF) looks inside the DBContext. Since we've defined a set there called Activities, it's going to give us a table called "Activities".
Inside "Activity", EF looks at the properties and decide what kind of cloumns they are going to be.
If there's a property called "Id", EF uses that property as the primary key into the table.
If there's no property called "Id", we need to specify what peoperty to use as a primary key.
We can use [Key] attribute to specify that
Creating a migration: 
    dotnet ef migrations add InitialCreate -p Persistence -s API
To actually create a database(This can be done through code):
    dotnet ef database update -p Persistence -s API 
To drop the database: 
    dotnet ef database drop -p .\Persistence\ -s .\API\


Section 2:
- Use Vite for quickly creating React applications. 
CORS: Cross-Origin Request Sharing. It's a security feature implemented by web browsers that restrict cross domain resource sharing.
Example, from localhost:5001 to localhost:3000
- In development mode, there might be 2 requests for the API call we are making.
Reason: We are operating in strict mode. When we are writing code in development and in strict mode, if we have UseEffect,
    it gets executed twice. It executes as the component mounts. And, it tests the cleanup code and it executes the useEffect again

To prevent error lines when working with Typescript, we need to give Typescript information about what a certain type is.
Use JsonToTs web tool to easily get type object

Section 4:
- Application layer is responsible for processing the business logic. The flow is such that we go from controllers in API via 
the application layer to the presenters in API layer
1. Controllers receive HTTP requests from client(React app)
2. Controller sends this request to Use-Case input port. This is application layer
3. "Use case interactor" processes the business logic and returns an output object through "Use-Case output port" to "Presenter" in API layer.
4. API presenter then sends out the HTTP Response. 
5. Idea is to use a mediator to achieve this

- CQRS(Command-Query-responsibility-Separation): Idea is to separate commands from queries.
Commands update/change state of the database.
Queries doesnt modify state, answers a question and returns a value.